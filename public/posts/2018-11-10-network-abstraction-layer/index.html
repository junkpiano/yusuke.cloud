<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Network Abstraction Layer | Yusuke Ohashi</title>
<meta name=keywords content>
<meta name=description content="I am experimenting a new way for network request in Kiri library. Kiri is Moya inspired abstract networking layer. I was very impressed by Moya architecture, so to learn from it the most, I decided to trace the same architecture by writing by myself, instead of copy and paste. :D
We need to break down client library into three parts.
Request Normally, you have to construct networking request every time. Instead, in Kiri, your network configuration is compiled in one place, like class, enum.">
<meta name=author content="Yusuke Ohashi">
<link rel=canonical href=https://yusuke.cloud/posts/2018-11-10-network-abstraction-layer/>
<link href=https://yusuke.cloud/assets/css/stylesheet.min.746a86b58bb2b052b5e4df8216510494f04f81e62c08d626150c26c69ca929da.css integrity="sha256-dGqGtYuysFK15N+CFlEElPBPgeYsCNYmFQwmxpypKdo=" rel="preload stylesheet" as=style>
<link rel=icon href=https://yusuke.cloud/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://yusuke.cloud/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://yusuke.cloud/favicon-32x32.png>
<link rel=apple-touch-icon href=https://yusuke.cloud/apple-touch-icon.png>
<link rel=mask-icon href=https://yusuke.cloud/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.1">
<link rel=alternate hreflang=en href=https://yusuke.cloud/posts/2018-11-10-network-abstraction-layer/>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-38557572-5','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="Network Abstraction Layer">
<meta property="og:description" content="I am experimenting a new way for network request in Kiri library. Kiri is Moya inspired abstract networking layer. I was very impressed by Moya architecture, so to learn from it the most, I decided to trace the same architecture by writing by myself, instead of copy and paste. :D
We need to break down client library into three parts.
Request Normally, you have to construct networking request every time. Instead, in Kiri, your network configuration is compiled in one place, like class, enum.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://yusuke.cloud/posts/2018-11-10-network-abstraction-layer/"><meta property="og:image" content="https://cdn.yusuke.cloud/assets/image/golden-gate-bridge.jpg"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-11-10T00:00:00+00:00">
<meta property="article:modified_time" content="2018-11-10T00:00:00+00:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://cdn.yusuke.cloud/assets/image/golden-gate-bridge.jpg">
<meta name=twitter:title content="Network Abstraction Layer">
<meta name=twitter:description content="I am experimenting a new way for network request in Kiri library. Kiri is Moya inspired abstract networking layer. I was very impressed by Moya architecture, so to learn from it the most, I decided to trace the same architecture by writing by myself, instead of copy and paste. :D
We need to break down client library into three parts.
Request Normally, you have to construct networking request every time. Instead, in Kiri, your network configuration is compiled in one place, like class, enum.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yusuke.cloud/posts/"},{"@type":"ListItem","position":3,"name":"Network Abstraction Layer","item":"https://yusuke.cloud/posts/2018-11-10-network-abstraction-layer/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Network Abstraction Layer","name":"Network Abstraction Layer","description":"I am experimenting a new way for network request in Kiri library. Kiri is Moya inspired abstract networking layer. I was very impressed by Moya architecture, so to learn from it the most, I decided to trace the same architecture by writing by myself, instead of copy and paste. :D\nWe need to break down client library into three parts.\nRequest Normally, you have to construct networking request every time. Instead, in Kiri, your network configuration is compiled in one place, like class, enum.","keywords":[],"articleBody":"I am experimenting a new way for network request in Kiri library. Kiri is Moya inspired abstract networking layer. I was very impressed by Moya architecture, so to learn from it the most, I decided to trace the same architecture by writing by myself, instead of copy and paste. :D\nWe need to break down client library into three parts.\nRequest Normally, you have to construct networking request every time. Instead, in Kiri, your network configuration is compiled in one place, like class, enum. And the class, enum must conform to RequestContainer protocol.\nSample code looks like this.\nenum TestAPIRequest { case getitems case postitem case updateitem case deleteitem } enum TestAPIRequest: RequestContainer { var baseURL: URL { return URL(string: \"https://www.example.com/api/v1\")! } var path: String { switch self { case .getitems: return \"/getitems\" ..... } } .... } It is better in terms of designing an API Client. Before you start to create client module, you can take a glance at whole structure. And you donâ€™t need to pass constant strings to every class, well while you wrap such things by extracting methods, since Kiri can have common parts like baseURL, so that you can avoid duplicate code in your app.\nBut if your api has different endpoints per API, or stuff like that, things are not that easy. In such case you might want to create seprate classses per API. It also makes sense. If you encounter such API (unfortunately), you had better take a look at APIKit instead. Itâ€™s supposed to have separate classses per API, and for response, itâ€™s more generic approach than Kiri or Moya.\nNetworking iOS has their own networking class, URLSession. But it makes no sense to wrap URLSession now. We have Alamofire. Alamofire automatically validates request and response, and also returns JSON. However, I prefer keeping response Data, since network library should support multiple response formats.\nKiri makes use of Alamofire for network request, and delegate building a request to it.\nIn the most cases, Alamofire works very well, but in case you need more premitive networking to build parameters by yourself, and so on, it might not be good for you.\nResponse I found there is a trade off. If you make response generic, your request will be fragmented to separate classes. On the other hand, if you make request generic, your response will be fragmented.\nI read code of both Moya and APIKit. In my opinion, these are the most sophisticated architecture in swift networking, whereas they have pros and cons.\nI donâ€™t find the best solution for networking yet, but for now, choosing wisely according to your app requirements would be the best answer.\nReferences  junkpiano/Kiri Moya/Moya ishkawa/APIKit  Kiri is the way smaller than Moya, but it is working fine in my personal project. Why not you try it!?\n","wordCount":"469","inLanguage":"en","datePublished":"2018-11-10T00:00:00Z","dateModified":"2018-11-10T00:00:00Z","author":{"@type":"Person","name":"Yusuke Ohashi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yusuke.cloud/posts/2018-11-10-network-abstraction-layer/"},"publisher":{"@type":"Organization","name":"Yusuke Ohashi","logo":{"@type":"ImageObject","url":"https://yusuke.cloud/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://yusuke.cloud accesskey=h title="Yusuke Ohashi (Alt + H)">Yusuke Ohashi</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<ul class=lang-switch><li>|</li>
<li>
<a href=https://yusuke.cloud/ja/ title=:jp: aria-label=:jp:>ðŸ‡¯ðŸ‡µ</a>
</li>
</ul>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://yusuke.cloud/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://yusuke.cloud/about/ title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://yusuke.cloud/posts/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=https://yusuke.cloud/index.xml title=RSS>
<span>RSS</span>
</a>
</li></ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Network Abstraction Layer
</h1>
<div class=post-meta>
November 10, 2018&nbsp;Â·&nbsp;Yusuke Ohashi
</div>
</header>
<div class=post-content>
<p>I am experimenting a new way for network request in <code>Kiri</code> library.
<code>Kiri</code> is <code>Moya</code> inspired abstract networking layer. I was very impressed by <code>Moya</code> architecture, so to learn from it the most, I decided to trace the same architecture by writing by myself, instead of copy and paste. :D</p>
<p>We need to break down client library into three parts.</p>
<h2 id=request>Request<a hidden class=anchor aria-hidden=true href=#request>#</a></h2>
<p>Normally, you have to construct networking request every time.
Instead, in Kiri, your network configuration is compiled in one place, like class, enum.
And the class, enum must conform to <code>RequestContainer</code> protocol.</p>
<p>Sample code looks like this.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>TestAPIRequest</span> {
  <span style=color:#66d9ef>case</span> getitems
  <span style=color:#66d9ef>case</span> postitem
  <span style=color:#66d9ef>case</span> updateitem
  <span style=color:#66d9ef>case</span> deleteitem
}

<span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>TestAPIRequest</span>: RequestContainer {
  <span style=color:#66d9ef>var</span> baseURL: URL {
    <span style=color:#66d9ef>return</span> URL(string: <span style=color:#e6db74>&#34;https://www.example.com/api/v1&#34;</span>)<span style=color:#f92672>!</span>
  }
  
  <span style=color:#66d9ef>var</span> path: String {
    <span style=color:#66d9ef>switch</span> <span style=color:#66d9ef>self</span> {
      <span style=color:#66d9ef>case</span> .getitems:
      <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;/getitems&#34;</span>
      .....
    }
  }
  
  ....
}
</code></pre></div><p>It is better in terms of designing an API Client.
Before you start to create client module, you can take a glance at whole structure.
And you don&rsquo;t need to pass constant strings to every class, well while you wrap such things by extracting methods, since Kiri can have common parts like <code>baseURL</code>, so that you can avoid duplicate code in your app.</p>
<p>But if your api has different endpoints per API, or stuff like that, things are not that easy. In such case you might want to create seprate classses per API. It also makes sense. If you encounter such API (unfortunately), you had better take a look at APIKit instead. It&rsquo;s supposed to have separate classses per API, and for response, it&rsquo;s more generic approach than Kiri or Moya.</p>
<h2 id=networking>Networking<a hidden class=anchor aria-hidden=true href=#networking>#</a></h2>
<p>iOS has their own networking class, URLSession. But it makes no sense to wrap URLSession now. <strong>We have <code>Alamofire</code>.</strong>
Alamofire automatically validates request and response, and also returns JSON. However, I prefer keeping response <code>Data</code>, since network library should support multiple response formats.</p>
<p>Kiri makes use of Alamofire for network request, and delegate building a request to it.</p>
<p>In the most cases, Alamofire works very well, but in case you need more premitive networking to build parameters by yourself, and so on, it might not be good for you.</p>
<h2 id=response>Response<a hidden class=anchor aria-hidden=true href=#response>#</a></h2>
<p>I found there is a trade off. If you make response generic, your request will be fragmented to separate classes. On the other hand, if you make request generic, your response will be fragmented.</p>
<p>I read code of both <code>Moya</code> and <code>APIKit</code>. In my opinion, these are the most sophisticated architecture in swift networking, whereas they have pros and cons.</p>
<p>I don&rsquo;t find the best solution for networking yet, but for now, choosing wisely according to your app requirements would be the best answer.</p>
<h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2>
<ul>
<li><a href=https://github.com/junkpiano/Kiri>junkpiano/Kiri</a></li>
<li><a href=https://github.com/Moya/Moya>Moya/Moya</a></li>
<li><a href=https://github.com/ishkawa/APIKit>ishkawa/APIKit</a></li>
</ul>
<p><em><code>Kiri</code> is the way smaller than Moya, but it is working fine in my personal project. Why not you try it!?</em></p>
</div>
<footer class=post-footer>
</footer>
</article>
</main><footer class=footer>
<span>&copy; 2021 <a href=https://yusuke.cloud>Yusuke Ohashi</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script defer src=https://yusuke.cloud/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>